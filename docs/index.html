<!DOCTYPE html><html><head><meta charset="utf8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="description" content="roots is a light, fast build system for advanced front end development"><meta name="author" content="jeff escalante"><title>roots | where it all begins</title><link rel="stylesheet" href="/css/main.css"><script src="//use.typekit.net/ltb5pgo.js"></script><script type="text/javascript">
(function() {
  var e;

  try {
    Typekit.load();
  } catch (_error) {
    e = _error;
  }

}).call(this);
</script></head><body><a href="http://github.com/jenius/roots" class="fork-ribbon">fork on github</a><header><a href="/" class="title"></a><nav><ul><li><a href="/#overview">overview</a></li><li><a href="/#installation">installation</a></li><li><a href="/#tutorials">tutorials</a></li><li><a href="/docs">documentation</a></li><li><a href="/axis">axis css</a></li><li><a href="/#help">help</a></li></ul></nav></header><div id="hero"><h2>roots <span>&#9889; </span>documentation</h2></div><div id="content" class="docs"><div id="docnav"><ul><li><a href="#tutorial">tutorial</a></li><li><a href="#cli">command line tool</a></li><li><a href="#axis">axis css</a></li><li><a href="#languages">languages</a></li><li><a href="#dynamic">dynamic content</a></li><li><a href="#precompile">precompiled views</a></li><li><a href="#client-side">client-side js</a></li><li><a href="#server">roots with a server</a></li><li><a href="#plugins">plugin api</a></li><li><a href="#templates">custom templates</a></li><li><a href="#multipass">multipass compilation</a></li></ul></div><h3 id="tutorial">tutorial: zero to ship in 5 minutes</h3><p>Roots is built for speed. And I&#39;m not just saying that because it sounds good, speed is actually the only purpose behind roots, and has been so from the beginning. Shipping a simple site in 5 minutes is actually not unheard of - I have done it a few times using roots. So no, this isn&#39;t a ridiculous tour-de-force example, this is real life.</p>
<p>Let&#39;s jump right into it. Start your timers, open up your command line, and get roots installing using <code>npm install roots -g</code>, if you don&#39;t have it installed already (shame on you!). To ensure that there are no errors, prefix it with <code>sudo</code>. Once finished, <code>cd</code> into wherever you want to create your site and run <code>roots new example</code>, with &#39;example&#39; being the name of your site. Now run <code>cd example</code>, then open up the folder in your <a href="http://www.sublimetext.com/">favorite text editor</a>.</p>
<p>Let&#39;s see how the site looks. From your command line, run <code>roots watch</code>, and within a second or so, the site should open in your browser. For the 5 minute ship edition, we don&#39;t need to learn about all the jade fanciness, so open up <code>views/index.jade</code>, delete the contents of the file, and put in <code>p hello world</code>. Save it.</p>
<p>As soon as you&#39;ve saved the file, you should see that your browser already refreshed to show your new content. How convenient. Ok, this site is finished, looks good. Stop the watcher with <code>control + c</code>, and let&#39;s deploy this bad boy. Make sure that you have the <a href="https://toolbelt.heroku.com/">heroku toolbelt</a> installed, and just run <code>roots deploy</code>. In about 20 seconds, your site should be online. Run <code>heroku open</code> to see it live.</p>
<p>That was refreshing, huh?</p>
<h3 id="cli">command line tool<p>See the <a href="man.html">man page</a></p>
</h3><h3 id="axis">axis css library</h3><p>Axis is a custom-built css library for stylus that ships with roots. It might take a bit to get down all the shortcuts that axis offers, but once you do, I promise it will speed up your css coding signficiantly.</p>
<p><a href="/axis">view axis css docs &raquo;</a></p>
<h3 id="languages">supported languages</h3><p>The default stack in roots is <a href="http://jade-lang.com/">jade</a>, <a href="http://learnboost.github.io/stylus/">stylus</a>, and <a href="http://coffeescript.org/">coffeescript</a>. I chose these languages for a few reasons, and I promise all of them were good. If you are unfamiliar with any of these languages, I would strongly urge you to give them a try. They are all well supported, mature, and robust languages that are used widely, and are very terse, clean, and powerful.</p>
<p>I do however understand that many people do not trust my language choices and have their own preferences. This is totally fine, and there are lots of options out there for you to make roots your own. First, you can write in vanilla html, css, and/or javascript without a problem. Just change the extension on the files to the appropriate one you are after, and everything will still compile out great. You will however lose a lot of the extra power, such as layouts, the css library etc. If you want to generate a project that has vanilla html/css/js from the beginning, you can add the <code>--basic</code> flag to your roots new command, like this: <code>roots new example --basic</code>.</p>
<p>I&#39;ve found that a number of people prefer to write html in a syntax more similar to vanilla html, but without losing the additional templating power that comes with jade. If this is the case for you, a language called <a href="https://github.com/visionmedia/ejs">ejs</a> is built in to roots by default, and you can see how a project using ejs looks by adding the <code>--ejs</code> flag to your roots new command, like this: <code>roots new example --ejs</code>. If you are familiar with ruby, ejs is the exact same as erb.</p>
<p>If writing css with semicolons and brackets is your jam, no worries. You can write css exactly like vanilla css in stylus. Brackets and semicolons are optional, so you can put them in if you want, or skip them. This is one of the things that makes stylus a truly excellent preprocessor.</p>
<p>If you don&#39;t like coffeescript, it&#39;s quite easy to simple change the file extension to <code>.js</code>. You will lose none of the additional power that comes with coffeescript, which is just great.</p>
<p>I&#39;ve also noticed that some people prefer working with haml/sass over jade/stylus. To be honest, they are hardly any different at all. Jade and stylus are slightly more terse if anything, and offer a small bit more power. In addition, the built in <a href="/axis">axis css library</a> provides a very near match to compass, and covers your ass in terms of vendor prefixes, older browser compatibility, and time-saving abbreviations. If you are so stuck on haml/sass/compass that you simply cannot branch out and try something new though, roots might not be your thing. These three aforementioned libraries are built in ruby, which does not jive too well with node, which roots is built on. If you are looking for a similar system that&#39;s built in ruby instead and defaults to haml/sass/compass, I would recommend checking out <a href="http://middlemanapp.com/">middleman</a>.</p>
<p>Finally, if you have any other languages that you are into, it&#39;s easy to extend roots to support any language, although js-based precompilers are the quickest to integrate. Check out the <a href="#plugins">documentation for plugins</a> for more info.</p>
<h3 id="dynamic">dynamic content</h3><p>Roots&#39; dynamic content is for the purpose of more cleanly handling pieces of content which belong to a group. Often times this can be determined by thinking of whether a master object could be said to &quot;have many of&quot; or be a collection of another set of objects, and when all of the set of objects that belong to the master object share properties, much like the way it&#39;s done with relational databases.</p>
<p>A great example of this is blog posts - a blog has many posts, and each post has a title, author, post date, and contents. Therefore, each post is a piece of dynamic content. On the other hand if you have an &quot;about&quot; page, you could say it has many pieces of content on it, maybe a photo, a video, and a few paragraphs, but since each of the pieces of content are entirely different, this would not be appropriate as a collection of dynamic content.</p>
<h5 id="basics">Basics</h5>
<p>It&#39;s easy to create and access collections of dynamic content with roots. To create one, first make a folder and name it what the collection is called. For example, if we were making a blog, we could call the folder &quot;posts&quot;, and inside of it would be all our blog posts.</p>
<p>Next, make a file in that folder which will be our first piece of dynamic content. To differentiate between normal and dynamic content, roots reads the files and looks for <a href="http://jekyllrb.com/docs/frontmatter/">yaml front matter</a> at the beginning of the file. The rest of the file can be any html you&#39;d like. Here&#39;s a sample of what you could add to your first blog post:</p>
<pre><code>---
title: &#39;Hello World&#39;
date: 6/23/2013
---

:markdown
  first post! **whoo**!</code></pre>
<p>After this has been done, when roots compiles, it will pull in an dynamic content and store it under a local variable in your html called <code>site</code>. Let&#39;s check this out -- in your <code>index.jade</code> file, drop this code:</p>
<pre><code>p!= JSON.stringify(site)</code></pre>
<p>When you compile, you&#39;ll see that now you have a namespace called <code>site.posts</code>, which was named after the folder your dynamic content is in, and it&#39;s an array of all the posts in the folder, which currently is just one. You can iterate through this object with jade to display an index of your blog posts.</p>
<p>Note that all the variables in the front matter are present, and anything underneath the front matter is compiled and stored in the <code>content</code> variable.</p>
<h5 id="ordering">Ordering</h5>
<p>There is also a local function built in to roots that will allow you to more easily sort and order your content. This function is available in all your view files, and is called <code>sort</code>. Here&#39;s an example of how it could be used.</p>
<pre><code>- sort(site.posts)</code></pre>
<p>This would look specifically for a property in the front matter called <code>order</code> (so it wouldn&#39;t work for our particular example), and sort by descending order. If you want to sort by another property, you can pass it in as an option:</p>
<pre><code>- sort(site.posts, { by: &#39;snargle&#39; })</code></pre>
<p>This would look for a front matter property called <code>snargle</code> and sort by that. For our blog, we want to sort by date. The order function has special handling for this, as long as you call the property &quot;date&quot;, it will do a proper date comparison.</p>
<pre><code>- sort(site.posts, { by: &#39;date&#39; })</code></pre>
<p>You can also choose whether it&#39;s in ascending or descending order. The default is always descending, but if you want to change this, just pass through the following option:</p>
<pre><code>- sort(site.posts, { order: &#39;asc&#39; })</code></pre>
<p>If you want to dig into the sort function a little more, <a href="https://github.com/jenius/roots/blob/master/lib/config_parser.js#L37">check out the source</a>. It&#39;s just javascript : )</p>
<h5 id="single-views">Single views</h5>
<p>Your blog wouldn&#39;t be complete unless each post had it&#39;s own single page view. Roots makes it easy for this to be implemented as well. All we need to do is add a <code>layout</code> property to the front matter, and reference a file by path relative to the post.</p>
<pre><code>---
title: &#39;Hello World&#39;
date: 6/23/2013
layout: ../views/_single_post.jade
---

:markdown
  first post! **whoo**!</code></pre>
<p>Now to finish it out, we&#39;ll just add a layout file at the path we defined. Note that single layouts for dynamic content get a special variable called <code>post</code> (it&#39;s always called <code>post</code> no matter what the folder name is), which holds the front matter variables, and the normal <code>content</code> variable holds the compiled content of the view, just like any other layout. Here&#39;s a simple example:</p>
<pre><code>head
  title= post.title
body
  h1= post.title
  != content</code></pre>
<blockquote>
<p><strong>note</strong>:
make sure that your single post layouts are not compiled on their own,
or they will throw an error. we avoided this using an underscore here.</p>
</blockquote>
<h5 id="tutorials">Tutorials</h5>
<p>There&#39;s a <a href="http://www.youtube.com/watch?v=Y7_WILKNAUE&amp;feature=youtu.be">video tutorial</a> available that walks through dynamic content. You can also run <code>roots new --blog</code> to get a project template that&#39;s set up to handle dynamic content already.</p>
<h3 id="precompile">precompiled views</h3><p>Roots can precompile specific templates and make them available in your views. This can be super convenient if you are loading content onto your page using javascript, making your markup much cleaner and easier to manage. Note that this is brand new functionality, so if you are having any issues please let me know, but in my testing and personal usage, it&#39;s been quite solid. Here&#39;s how to make it happen:</p>
<ul>
<li><p>In your <code>app.coffee</code> file, you should see a commented out line setting <code>exports.templates</code> to a path. Uncomment this line, set the path to whatever you&#39;d like, and create a folder at that path.</p>
</li>
<li><p>Put a jade file inside that folder. This will be your template, so create it as you&#39;d like. Currently only jade is supported for precompiled templates.</p>
</li>
<li><p>When you compile your project, it will now create a file called <code>templates.js</code> inside your <code>js</code> folder. Load this file on to your page either directly or using require.js.</p>
</li>
<li><p>You should now have access to a global variable called <code>templates</code> -- this is an object that holds each of your precompiled templates as javascript functions. The key will be the filename, and the value will be a function that when executed will generate html. If you have any variables in the template, pass in a single object that holds the variable names as keys and variables values as values.</p>
</li>
<li><p>Check out <a href="http://www.youtube.com/watch?v=_lPLVd0UsdI">this tutorial</a> for a setp-by-step rundown.</p>
</li>
</ul>
<h3 id="client-side">client-side js<p>Roots wraps a couple client-side javascript package managers, the default being <a href="http://bower.io">bower</a>. If you run <code>roots pkg</code>, it will expose bower&#39;s interface and you can interact with bower that way. Any command given after <code>roots pkg &lt;command&gt;</code> will be run as if it were running <code>bower &lt;command&gt;</code>. You do not need to have bower installed globally to use this. All packages will be installed into <code>assets/components</code>.</p>
<p>To see bower&#39;s command options, run <code>roots pkg</code> and it will print them for you.</p>
<p>In the future, roots will be compatible with more package managers, if you prefer one other than bower. As a test, we have added <a href="https://github.com/jenus/cli-js">a cdnjs package manager</a> to v2.0.0. If you&#39;d like to try this out, open the <code>~/.rootsrc</code> file and change the value of <code>package_manager</code> from <code>bower</code> to <code>cdnjs</code>. As we add more package managers, this interface will be made simpler.</p>
</h3><h3 id="server">roots with a server</h3><p>It is possible to use roots with a server, although obviously you don&#39;t get any of the static compilation etc. The main pieces of roots that can be helpful with a server-side app are the languages, live reloading, and the css library.</p>
<p>I have a plugin written for <a href="http://expressjs.com/">express</a> that sets up express with the default stack of jade, coffee, and stylus, includes the css library, and sets up live reloads, so this works pretty well. To create a roots app backed by express, just run <code>roots new example --express</code>, with example being the name of your app. Once you are using an express app, command line options like <code>roots watch</code> no longer apply - you can run the app the way express specifies (with <code>node app.js</code>).</p>
<p>I also have a rails gem written that includes stylus and the css library, and gets the language stack as close as possible. You can check out this gem in the <a href="http://github.com/jenius/roots-rails">roots-rails repo</a> if you are interested. It&#39;s worth noting that at the moment, the rails gem does not support the asset pipeline though. Fixing this is on my to-do list.</p>
<p>I&#39;m happy to think about extending roots to any other platforms that people are interested in as well, just hit me up <a href="http://twitter.com/jescalan">on twitter</a> and let me know what you&#39;re thinking.</p>
<h3 id="plugins">plugins<p>Roots ships with a few core compilers that are optimized for a speedy and efficient workflow. But of course everyone has their own preferred tools, and if there are languages you would rather work in, you can build them in to roots through the plugin interface.</p>
<p>Plugins need only be one file, and are frequently less than 10 lines of javascript (many of the core compilers are, actually). To create a plugin, just drop a new file, javascript or coffeescript, into <code>/plugins</code>. The module need only export two methods, <code>settings</code> and <code>compile</code>. To get you started, you can run <code>roots plugin generate</code> to have roots generate a basic plugin template.</p>
<p>Here are a few examples of how plugins can look. Note that plugins are executed inside roots&#39; environment, so if you want to require any external files, you need to use <code>module.require()</code> instead of just <code>require()</code> in order to have roots look for files starting in the plugins directory.</p>
<ul>
<li><a href="https://github.com/jenius/roots/blob/master/lib/adapters/jade.js">jade compiler</a></li>
<li><a href="https://github.com/jenius/roots/blob/master/lib/adapters/styl.js">stylus compiler</a></li>
<li><a href="https://github.com/jenius/roots/blob/master/lib/adapters/coffee.js">coffeescript compiler</a></li>
</ul>
<h5 id="file-object">File Object</h5>
<p>You will notice that the plugin&#39;s compile method is passed two params, the first one being a <code>file</code> object which holds a large amount of information about the file being compiled, and the second is a callback. Below is documentation for the properties of the <code>file</code> object.</p>
<p><strong><code>file.path</code></strong><br>Returns the absolute path of the current file</p>
<p><strong><code>file.contents</code></strong><br>Returns a string with the contents of the current file</p>
<p><strong><code>file.extension</code></strong><br>Returns the extension of the current file</p>
<p><strong><code>file.target_extension</code></strong><br>Returns the extension that the file will compile into</p>
<p><strong><code>file.export_path</code></strong><br>Returns the absolute path where file will be written after compile</p>
<p><strong><code>file.layout_path</code></strong><br><em>If the file&#39;s target extension is html</em>, Returns the absolute path of the layout file it will be compiled into.</p>
<p><strong><code>file.layout_contents</code></strong><br><em>If the file&#39;s target extension is html</em>, Returns the contents of the layout file it will be compiled into.</p>
<p><strong><code>file.locals(extra_object)</code></strong><br>Returns all the local functions to be rendered with a view template. If you pass it an object, it will include it in the locals. You will want to add yield when compiling the layout, like in the ejs compiler example above.</p>
<h5 id="notes">Notes</h5>
<p>If you console.log out a dynamic file, you may find more properties that are set as part of dynamic file parsing, but don&#39;t worry about these. Messing with the dynamic content properties inside a compiler is a terrible idea - <strong>all a compiler should do is transform the file contents</strong>.</p>
<p>Note that if you are writing a plugin that parses html, <strong>it must return a function</strong> if you want to it have access to the locals. If it returns a string, locals will not be available. Every other file format should return a string.</p>
<p>If you want to dig into the file class a bit more, feel free to <a href="https://github.com/jenius/roots/blob/master/lib/utils/file_helper.js">check out the source</a>, but be warned that this particular file is wildly complicated.</p>
<p>The following commands are also available to make working with plugins easier.</p>
<ul>
<li><code>roots plugin generate</code> generates a plugin template for you in the <code>/plugins</code> folder.</li>
<li><code>roots plugin install github-username/repo</code> installs a plugin to <code>/plugins</code> from github.</li>
</ul>
</h3><h3 id="templates">custom templates</h3><p>So maybe you like the idea of roots, but coffeescript isn&#39;t your thing. Or it bothers you that requirejs is the default and you prefer another way of doing it. Or maybe (<em>shudder</em>) you like twitter bootstrap by default. As of <code>v2.0.0</code>, roots allows you to create custom roots templates and use them to initialize your projects.</p>
<p>To add your own template, all you have to do is create it, upload it to a service like github, then run:</p>
<p><code>roots template add mytemplate https://github.com/exampleuser/mytemplate</code>.</p>
<p>Now when you are making a new project, use <code>roots new &lt;name&gt; --mytemplate</code>. Or even better, if you want it to be the default, run <code>roots template default mytemplate</code>, and it will use your custom template when you call <code>roots new &lt;name&gt;</code> without args.</p>
<p>For more details on adding, removing, and using templates, <a href="man.html#TEMPLATE">see the man page</a></p>
<h3 id="multipass">multipass compilation</h3><p>As of version <code>2.0.0</code>, roots can compile a single file multiple times and for different languages. This can be very useful if you are trying to do some more advanced types of generation with roots. Over the next few release cycles, more examples will surface of multipass compilation being used in order to accomplish some fantastic things. Let&#39;s start with the basics though. Let&#39;s say you want to parse jade, but first make everything uppercase, because that&#39;s a great time.</p>
<p>First, you need a new compiler. We&#39;ll call it <code>upcaser</code>. We can add compilers to roots using the plugin api, documented above. Here&#39;s a simple plugin that will just upcase everything.</p>
<pre><code>exports.settings =
  file_type: &#39;upcase&#39;
  target: &#39;&#39;

exports.compile = (file, callback) -&gt;
  error = false
  compiled_contents = null

  try
    compiled_contents = file.contents.toUpperCase()
  catch err
    error = err

  callback(error, compiled_contents)</code></pre>
<p>If we drop this file in a <code>plugins</code> folder at the root, it will be added to the pipeline. Now all that&#39;s left is adding our new &quot;upcase&quot; extension to a file and seeing what happens. Change <code>index.jade</code> to <code>index.jade.upcase</code>, and run <code>roots watch</code>. Enjoy the ease with which you just ruined your website, and feel the power of multipass compilation coursing through your veins.</p>
</div><footer></footer></body><script data-main="/js/main" src="/js/require.js"></script><script>var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-37002571-1']);_gaq.push(['_setDomainName', 'roots.cx']);_gaq.push(['_trackPageview']);
(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></html>